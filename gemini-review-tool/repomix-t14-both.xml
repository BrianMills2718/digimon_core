This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/tools/phase1/t14_email_parser_unified.py, tests/unit/test_t14_email_parser_unified.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  tools/
    phase1/
      t14_email_parser_unified.py
tests/
  unit/
    test_t14_email_parser_unified.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/tools/phase1/t14_email_parser_unified.py">
"""
T14 Email Parser Unified Tool

Processes email files (.eml, .msg) using email and msg_parser modules for real email parsing.
Implements unified BaseTool interface with comprehensive email processing capabilities.
"""

import email
import email.header
import email.utils
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import logging
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional, Union
import chardet
import re
import base64
import quopri

try:
    import extract_msg  # For .msg file support
    MSG_SUPPORT = True
except ImportError:
    MSG_SUPPORT = False

from src.tools.base_tool import BaseTool, ToolRequest, ToolResult, ToolErrorCode
from src.core.service_manager import ServiceManager

class T14EmailParserUnified(BaseTool):
    """
    Email Parser tool for processing email files (.eml, .msg) with real email parsing.
    
    Features:
    - Real email parsing using email module
    - Header extraction and decoding
    - Attachment processing and extraction
    - Multiple encoding support
    - .msg file support (if extract_msg available)
    - HTML/text content extraction
    - Metadata analysis
    """
    
    def __init__(self, service_manager: ServiceManager):
        super().__init__(service_manager)
        self.tool_id = "T14"
        self.name = "Email Parser"
        self.category = "document_processing"
        self.service_manager = service_manager  # Store for use in methods
        
        # Email processing stats
        self.attachments_extracted = 0
        self.headers_decoded = 0
        self.encoding_detections = 0

    def execute(self, request: ToolRequest) -> ToolResult:
        """Execute email parsing with real email processing"""
        self._start_execution()
        
        try:
            # Validate input
            validation_result = self._validate_input(request.input_data)
            if not validation_result["valid"]:
                execution_time, memory_used = self._end_execution()
                return ToolResult(
                    tool_id=self.tool_id,
                    status="error",
                    data={},
                    error_message=validation_result["error"],
                    error_code=ToolErrorCode.INVALID_INPUT,
                    execution_time=execution_time,
                    memory_used=memory_used
                )
            
            email_path = request.input_data.get("email_path")
            extract_attachments = request.input_data.get("extract_attachments", True)
            output_dir = request.input_data.get("output_dir", None)
            
            # Check file exists
            if not os.path.exists(email_path):
                execution_time, memory_used = self._end_execution()
                return ToolResult(
                    tool_id=self.tool_id,
                    status="error",
                    data={},
                    error_message=f"Email file not found: {email_path}",
                    error_code=ToolErrorCode.FILE_NOT_FOUND,
                    execution_time=execution_time,
                    memory_used=memory_used
                )
            
            # Process email based on file type
            file_ext = Path(email_path).suffix.lower()
            
            if file_ext == '.msg':
                if not MSG_SUPPORT:
                    execution_time, memory_used = self._end_execution()
                    return ToolResult(
                        tool_id=self.tool_id,
                        status="error",
                        data={},
                        error_message="MSG file support requires extract-msg package",
                        error_code=ToolErrorCode.PROCESSING_ERROR,
                        execution_time=execution_time,
                        memory_used=memory_used
                    )
                result_data = self._process_msg_file(email_path, extract_attachments, output_dir)
            else:
                # Handle .eml and other text-based email formats
                result_data = self._process_eml_file(email_path, extract_attachments, output_dir)
            
            # Create mentions for processed data
            self._create_service_mentions(result_data)
            
            # Calculate confidence based on content quality
            confidence = self._calculate_confidence(result_data)
            
            execution_time, memory_used = self._end_execution()
            
            return ToolResult(
                tool_id=self.tool_id,
                status="success",
                data={
                    "email_data": result_data,
                    "stats": {
                        "attachments_extracted": self.attachments_extracted,
                        "headers_decoded": self.headers_decoded,
                        "encoding_detections": self.encoding_detections
                    },
                    "confidence": confidence
                },
                execution_time=execution_time,
                memory_used=memory_used
            )
            
        except Exception as e:
            execution_time, memory_used = self._end_execution()
            logging.error(f"T14 Email Parser error: {str(e)}")
            return ToolResult(
                tool_id=self.tool_id,
                status="error",
                data={},
                error_message=f"Email parsing failed: {str(e)}",
                error_code=ToolErrorCode.PROCESSING_ERROR,
                execution_time=execution_time,
                memory_used=memory_used
            )

    def _process_eml_file(self, email_path: str, extract_attachments: bool, output_dir: Optional[str]) -> Dict[str, Any]:
        """Process .eml file using email module"""
        
        # Read email file with encoding detection
        with open(email_path, 'rb') as f:
            raw_email = f.read()
        
        # Detect encoding
        encoding_result = chardet.detect(raw_email)
        encoding = encoding_result.get('encoding', 'utf-8')
        self.encoding_detections += 1
        
        # Parse email
        try:
            email_str = raw_email.decode(encoding, errors='replace')
        except:
            email_str = raw_email.decode('utf-8', errors='replace')
            
        msg = email.message_from_string(email_str)
        
        # Extract headers
        headers = self._extract_headers(msg)
        
        # Extract body content
        body_data = self._extract_body_content(msg)
        
        # Extract attachments (always extract metadata, conditionally save files)
        attachments = self._extract_attachments(msg, output_dir if extract_attachments else None)
        
        # Extract metadata
        metadata = self._extract_email_metadata(msg, email_path)
        
        return {
            "headers": headers,
            "body": body_data,
            "attachments": attachments,
            "metadata": metadata,
            "message_id": headers.get("message_id"),
            "thread_id": headers.get("in_reply_to"),
            "file_path": email_path,
            "file_type": "eml"
        }

    def _process_msg_file(self, email_path: str, extract_attachments: bool, output_dir: Optional[str]) -> Dict[str, Any]:
        """Process .msg file using extract_msg module"""
        
        msg = extract_msg.openMsg(email_path)
        
        try:
            # Extract headers from MSG
            headers = {
                "from": getattr(msg, 'sender', ''),
                "to": getattr(msg, 'to', ''),
                "cc": getattr(msg, 'cc', ''),
                "bcc": getattr(msg, 'bcc', ''),
                "subject": getattr(msg, 'subject', ''),
                "date": getattr(msg, 'date', ''),
                "message_id": getattr(msg, 'messageId', ''),
                "in_reply_to": getattr(msg, 'inReplyTo', ''),
                "reply_to": getattr(msg, 'replyTo', '')
            }
            self.headers_decoded += len([v for v in headers.values() if v])
            
            # Extract body content
            body_data = {
                "plain_text": getattr(msg, 'body', ''),
                "html_content": getattr(msg, 'htmlBody', ''),
                "rtf_content": getattr(msg, 'rtfBody', '') if hasattr(msg, 'rtfBody') else ''
            }
            
            # Extract attachments from MSG (always extract metadata, conditionally save files)
            attachments = []
            if hasattr(msg, 'attachments'):
                for attachment in msg.attachments:
                    att_data = {
                        "filename": getattr(attachment, 'longFilename') or getattr(attachment, 'shortFilename', 'unknown'),
                        "size": len(getattr(attachment, 'data', b'')),
                        "content_type": "application/octet-stream"
                    }
                    
                    if extract_attachments and output_dir and hasattr(attachment, 'save'):
                        os.makedirs(output_dir, exist_ok=True)
                        save_path = os.path.join(output_dir, att_data["filename"])
                        attachment.save(customPath=save_path)
                        att_data["saved_path"] = save_path
                        self.attachments_extracted += 1
                    
                    attachments.append(att_data)
            
            # Extract metadata
            metadata = {
                "creation_time": getattr(msg, 'creationTime', None),
                "last_modification_time": getattr(msg, 'lastModificationTime', None),
                "message_class": getattr(msg, 'messageClass', ''),
                "importance": getattr(msg, 'importance', 'normal'),
                "priority": getattr(msg, 'priority', 'normal'),
                "sensitivity": getattr(msg, 'sensitivity', 'none'),
                "file_size": os.path.getsize(email_path),
                "encoding_detected": "MSG format"
            }
            
            return {
                "headers": headers,
                "body": body_data,
                "attachments": attachments,
                "metadata": metadata,
                "message_id": headers.get("message_id"),
                "thread_id": headers.get("in_reply_to"),
                "file_path": email_path,
                "file_type": "msg"
            }
            
        finally:
            msg.close()

    def _extract_headers(self, msg: email.message.Message) -> Dict[str, str]:
        """Extract and decode email headers"""
        headers = {}
        
        header_fields = [
            'from', 'to', 'cc', 'bcc', 'subject', 'date', 'message-id',
            'in-reply-to', 'references', 'reply-to', 'return-path',
            'x-mailer', 'x-originating-ip', 'received', 'content-type'
        ]
        
        for field in header_fields:
            value = msg.get(field, '')
            if value:
                # Decode header if needed
                decoded_value = self._decode_header(value)
                headers[field.replace('-', '_')] = decoded_value
                self.headers_decoded += 1
        
        return headers

    def _decode_header(self, header_value: str) -> str:
        """Decode RFC 2047 encoded headers"""
        try:
            decoded_parts = email.header.decode_header(header_value)
            decoded_string = ""
            
            for part, encoding in decoded_parts:
                if isinstance(part, bytes):
                    if encoding:
                        decoded_string += part.decode(encoding, errors='replace')
                    else:
                        # Try to detect encoding
                        detected = chardet.detect(part)
                        enc = detected.get('encoding', 'utf-8')
                        decoded_string += part.decode(enc, errors='replace')
                else:
                    decoded_string += part
            
            return decoded_string.strip()
        except:
            return header_value

    def _extract_body_content(self, msg: email.message.Message) -> Dict[str, str]:
        """Extract body content from email message"""
        body_data = {
            "plain_text": "",
            "html_content": "",
            "attachments_found": 0
        }
        
        if msg.is_multipart():
            for part in msg.walk():
                content_type = part.get_content_type()
                content_disposition = str(part.get("Content-Disposition", ""))
                
                # Skip attachments in body extraction
                if "attachment" in content_disposition:
                    body_data["attachments_found"] += 1
                    continue
                
                if content_type == "text/plain":
                    payload = self._get_decoded_payload(part)
                    body_data["plain_text"] += payload + "\n"
                elif content_type == "text/html":
                    payload = self._get_decoded_payload(part)
                    body_data["html_content"] += payload + "\n"
        else:
            # Single part message
            content_type = msg.get_content_type()
            payload = self._get_decoded_payload(msg)
            
            if content_type == "text/plain":
                body_data["plain_text"] = payload
            elif content_type == "text/html":
                body_data["html_content"] = payload
            else:
                body_data["plain_text"] = payload
        
        return body_data

    def _get_decoded_payload(self, part: email.message.Message) -> str:
        """Get decoded payload from email part"""
        try:
            payload = part.get_payload(decode=True)
            if isinstance(payload, bytes):
                # Try to get charset from content type
                charset = part.get_content_charset()
                if charset:
                    return payload.decode(charset, errors='replace')
                else:
                    # Detect encoding
                    detected = chardet.detect(payload)
                    encoding = detected.get('encoding', 'utf-8')
                    self.encoding_detections += 1
                    return payload.decode(encoding, errors='replace')
            else:
                return str(payload)
        except:
            # Fallback to string payload
            return str(part.get_payload())

    def _extract_attachments(self, msg: email.message.Message, output_dir: Optional[str]) -> List[Dict[str, Any]]:
        """Extract attachments from email message"""
        attachments = []
        
        for part in msg.walk():
            content_disposition = str(part.get("Content-Disposition", ""))
            
            if "attachment" in content_disposition:
                filename = part.get_filename()
                if filename:
                    # Decode filename if needed
                    filename = self._decode_header(filename)
                    
                    # Get attachment data
                    payload = part.get_payload(decode=True)
                    
                    att_data = {
                        "filename": filename,
                        "size": len(payload) if payload else 0,
                        "content_type": part.get_content_type(),
                        "content_id": part.get("Content-ID", ""),
                        "encoding": part.get("Content-Transfer-Encoding", "")
                    }
                    
                    # Save attachment if output directory specified
                    if output_dir and payload:
                        os.makedirs(output_dir, exist_ok=True)
                        safe_filename = re.sub(r'[^\w\-_\.]', '_', filename)
                        save_path = os.path.join(output_dir, safe_filename)
                        
                        with open(save_path, 'wb') as f:
                            f.write(payload)
                        
                        att_data["saved_path"] = save_path
                        self.attachments_extracted += 1
                    
                    attachments.append(att_data)
        
        return attachments

    def _extract_email_metadata(self, msg: email.message.Message, email_path: str) -> Dict[str, Any]:
        """Extract metadata from email"""
        return {
            "file_size": os.path.getsize(email_path),
            "creation_time": datetime.fromtimestamp(os.path.getctime(email_path)).isoformat(),
            "modification_time": datetime.fromtimestamp(os.path.getmtime(email_path)).isoformat(),
            "is_multipart": msg.is_multipart(),
            "content_type": msg.get_content_type(),
            "encoding_detected": "auto-detected",
            "has_attachments": len([p for p in msg.walk() if p.get_filename()]) > 0,
            "part_count": len(list(msg.walk())) if msg.is_multipart() else 1
        }

    def _calculate_confidence(self, result_data: Dict[str, Any]) -> float:
        """Calculate confidence score based on parsing success"""
        confidence = 0.5  # Base confidence
        
        # Increase confidence based on successful extractions
        if result_data.get("headers", {}).get("subject"):
            confidence += 0.15
        
        if result_data.get("headers", {}).get("from"):
            confidence += 0.1
        
        if result_data.get("body", {}).get("plain_text") or result_data.get("body", {}).get("html_content"):
            confidence += 0.15
        
        if result_data.get("attachments"):
            confidence += 0.1
        
        # Bonus for complete metadata
        if result_data.get("metadata", {}).get("file_size", 0) > 0:
            confidence += 0.05
        
        return min(confidence, 1.0)

    def _create_service_mentions(self, result_data: Dict[str, Any]):
        """Create service mentions for processed email data"""
        try:
            # Create mention for sender
            sender = result_data.get("headers", {}).get("from", "")
            if sender and hasattr(self.service_manager, 'identity_service'):
                self.service_manager.identity_service.create_mention(
                    surface_form=sender,
                    start_pos=0,
                    end_pos=len(sender),
                    source_ref=result_data.get("file_path", ""),
                    entity_type="email_sender",
                    confidence=0.9
                )
                
                # Create provenance record
                if hasattr(self.service_manager, 'provenance_service'):
                    self.service_manager.provenance_service.create_provenance_record(
                        tool_id=self.tool_id,
                        operation="email_processed",
                        input_data=result_data.get("file_path", ""),
                        output_data={"sender": sender}
                    )
        except Exception as e:
            logging.warning(f"Service mention creation failed: {e}")

    def _validate_input(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate input parameters"""
        if not input_data:
            return {"valid": False, "error": "email_path parameter required"}
        
        if "email_path" not in input_data:
            return {"valid": False, "error": "email_path parameter required"}
        
        email_path = input_data["email_path"]
        if not isinstance(email_path, str) or not email_path.strip():
            return {"valid": False, "error": "email_path must be non-empty string"}
        
        # Validate file extension
        valid_extensions = ['.eml', '.msg', '.email', '.mbox']
        file_ext = Path(email_path).suffix.lower()
        if file_ext not in valid_extensions:
            return {"valid": False, "error": f"Unsupported email format: {file_ext}. Supported: {valid_extensions}"}
        
        return {"valid": True}

    def get_contract(self):
        """Return tool contract specification"""
        return {
            "tool_id": self.tool_id,
            "name": self.name,
            "category": self.category,
            "description": "Parse email files (.eml, .msg) and extract headers, body, attachments, and metadata",
            "input_schema": {
                "type": "object",
                "properties": {
                    "email_path": {
                        "type": "string",
                        "description": "Path to email file (.eml, .msg, .email, .mbox)"
                    },
                    "extract_attachments": {
                        "type": "boolean",
                        "description": "Whether to extract attachment data",
                        "default": True
                    },
                    "output_dir": {
                        "type": "string",
                        "description": "Directory to save extracted attachments (optional)"
                    }
                },
                "required": ["email_path"]
            },
            "output_schema": {
                "type": "object",
                "properties": {
                    "email_data": {
                        "type": "object",
                        "description": "Parsed email data including headers, body, attachments, metadata"
                    },
                    "stats": {
                        "type": "object",
                        "description": "Processing statistics"
                    }
                }
            },
            "error_codes": [
                ToolErrorCode.INVALID_INPUT,
                ToolErrorCode.FILE_NOT_FOUND,
                ToolErrorCode.PROCESSING_ERROR
            ]
        }

    def health_check(self) -> Dict[str, Any]:
        """Perform health check for email parsing capabilities"""
        try:
            # Test email module availability
            import email
            import email.header
            import email.utils
            
            # Test encoding detection
            import chardet
            
            # Check MSG support
            msg_available = MSG_SUPPORT
            
            # Test creating a simple email
            test_msg = MIMEText("Test email content")
            test_msg["Subject"] = "Test Subject"
            test_msg["From"] = "test@example.com"
            test_msg["To"] = "recipient@example.com"
            
            # Parse it back
            parsed = email.message_from_string(str(test_msg))
            
            return {
                "status": "healthy",
                "email_module": "available",
                "chardet_module": "available",
                "msg_support": msg_available,
                "test_parsing": "successful",
                "supported_formats": [".eml", ".msg" if msg_available else "(.msg requires extract-msg)", ".email", ".mbox"]
            }
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e)
            }

    def cleanup(self):
        """Clean up resources"""
        self.attachments_extracted = 0
        self.headers_decoded = 0
        self.encoding_detections = 0
</file>

<file path="tests/unit/test_t14_email_parser_unified.py">
"""
Mock-free unit tests for T14 Email Parser Unified Tool

Tests real email parsing with email module and temporary email files.
Achieves comprehensive coverage through real functionality testing.
"""

import pytest
import tempfile
import os
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email import encoders
import base64
from pathlib import Path
from datetime import datetime

from src.tools.phase1.t14_email_parser_unified import T14EmailParserUnified
from src.core.service_manager import ServiceManager
from src.tools.base_tool import ToolRequest

class TestT14EmailParserUnifiedMockFree:
    """Mock-free test suite for T14 Email Parser - NO mocks used"""
    
    def setup_method(self):
        # Real ServiceManager - NO mocks
        self.service_manager = ServiceManager()
        self.tool = T14EmailParserUnified(service_manager=self.service_manager)
        
        # Create real test email files
        self.test_email_files = self._create_real_test_email_files()
        
    def _create_real_test_email_files(self) -> dict:
        """Create actual email files for testing"""
        files = {}
        
        # Simple text email
        simple_msg = MIMEText("This is a simple test message.\nLine 2 of the message.", "plain", "utf-8")
        simple_msg["Subject"] = "Test Subject - Simple Email"
        simple_msg["From"] = "sender@example.com"
        simple_msg["To"] = "recipient@example.com"
        simple_msg["Date"] = "Wed, 22 Jul 2025 10:30:00 -0700"
        simple_msg["Message-ID"] = "<test123@example.com>"
        
        simple_file = tempfile.NamedTemporaryFile(mode='w', suffix='.eml', delete=False, encoding='utf-8')
        simple_file.write(str(simple_msg))
        simple_file.close()
        files['simple'] = simple_file.name
        
        # Multipart email with HTML and text
        multipart_msg = MIMEMultipart("alternative")
        multipart_msg["Subject"] = "Test Subject - Multipart Email"
        multipart_msg["From"] = "sender@company.com"
        multipart_msg["To"] = "recipient@company.com, cc@company.com"
        multipart_msg["CC"] = "cc@company.com"
        multipart_msg["Date"] = "Wed, 22 Jul 2025 11:00:00 -0700"
        multipart_msg["Message-ID"] = "<multipart456@company.com>"
        multipart_msg["In-Reply-To"] = "<original789@company.com>"
        
        text_part = MIMEText("This is the plain text version.\nWith multiple lines.", "plain", "utf-8")
        html_part = MIMEText("<html><body><h1>HTML Version</h1><p>This is the <b>HTML</b> version.</p></body></html>", "html", "utf-8")
        
        multipart_msg.attach(text_part)
        multipart_msg.attach(html_part)
        
        multipart_file = tempfile.NamedTemporaryFile(mode='w', suffix='.eml', delete=False, encoding='utf-8')
        multipart_file.write(str(multipart_msg))
        multipart_file.close()
        files['multipart'] = multipart_file.name
        
        # Email with attachments
        attachment_msg = MIMEMultipart()
        attachment_msg["Subject"] = "Test Subject - With Attachments"
        attachment_msg["From"] = "files@example.com"
        attachment_msg["To"] = "user@example.com"
        attachment_msg["Date"] = "Wed, 22 Jul 2025 12:00:00 -0700"
        
        # Add body
        body_text = MIMEText("Please find attached files.", "plain", "utf-8")
        attachment_msg.attach(body_text)
        
        # Add text attachment
        text_attachment = MIMEBase('application', 'octet-stream')
        text_content = b"This is attachment content.\nLine 2 of attachment."
        text_attachment.set_payload(text_content)
        encoders.encode_base64(text_attachment)
        text_attachment.add_header('Content-Disposition', 'attachment; filename="test_document.txt"')
        attachment_msg.attach(text_attachment)
        
        # Add image attachment
        image_attachment = MIMEImage(b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x02\x00\x00\x00\x90wS\xde\x00\x00\x00\tpHYs\x00\x00\x0b\x13\x00\x00\x0b\x13\x01\x00\x9a\x9c\x18\x00\x00\x00\nIDATx\x9cc\xf8\x00\x00\x00\x01\x00\x01\x1c\x04[7\x00\x00\x00\x00IEND\xaeB`\x82')
        image_attachment.add_header('Content-Disposition', 'attachment; filename="test_image.png"')
        attachment_msg.attach(image_attachment)
        
        attachment_file = tempfile.NamedTemporaryFile(mode='w', suffix='.eml', delete=False, encoding='utf-8')
        attachment_file.write(str(attachment_msg))
        attachment_file.close()
        files['with_attachments'] = attachment_file.name
        
        # Email with encoded headers
        encoded_msg = MIMEText("Message with encoded headers", "plain", "utf-8")
        encoded_msg["Subject"] = "=?utf-8?B?VGVzdCBTdWJqZWN0IHdpdGggw5bDpMOc?="  # "Test Subject with ÖäÜ"
        encoded_msg["From"] = "=?utf-8?Q?John_D=C3=B6e?= <john@example.com>"  # "John Döe"
        encoded_msg["To"] = "user@example.com"
        encoded_msg["Date"] = "Wed, 22 Jul 2025 13:00:00 -0700"
        
        encoded_file = tempfile.NamedTemporaryFile(mode='w', suffix='.eml', delete=False, encoding='utf-8')
        encoded_file.write(str(encoded_msg))
        encoded_file.close()
        files['encoded_headers'] = encoded_file.name
        
        # Email with different encodings
        latin1_content = "Mensaje con acentos: café, niño, señor"
        latin1_msg = MIMEText(latin1_content, "plain", "latin-1")
        latin1_msg["Subject"] = "Test Latin-1 Encoding"
        latin1_msg["From"] = "spanish@example.com"
        latin1_msg["To"] = "user@example.com"
        latin1_msg["Date"] = "Wed, 22 Jul 2025 14:00:00 -0700"
        
        latin1_file = tempfile.NamedTemporaryFile(mode='w', suffix='.eml', delete=False, encoding='latin-1')
        latin1_file.write(str(latin1_msg))
        latin1_file.close()
        files['latin1_encoding'] = latin1_file.name
        
        # Malformed email for error testing
        malformed_file = tempfile.NamedTemporaryFile(mode='w', suffix='.eml', delete=False, encoding='utf-8')
        malformed_file.write("This is not a valid email message\nJust random text\n")
        malformed_file.close()
        files['malformed'] = malformed_file.name
        
        return files
    
    def teardown_method(self):
        """Clean up test files"""
        for file_path in self.test_email_files.values():
            try:
                os.unlink(file_path)
            except:
                pass
    
    def test_simple_email_parsing_real(self):
        """Test parsing simple text email with real email module"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={
                "email_path": self.test_email_files['simple'],
                "extract_attachments": False
            },
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        assert result.data["email_data"]["headers"]["subject"] == "Test Subject - Simple Email"
        assert result.data["email_data"]["headers"]["from"] == "sender@example.com"
        assert result.data["email_data"]["headers"]["to"] == "recipient@example.com"
        assert "This is a simple test message" in result.data["email_data"]["body"]["plain_text"]
        assert result.data["email_data"]["file_type"] == "eml"
        assert result.data["confidence"] > 0.7
        assert result.execution_time > 0
    
    def test_multipart_email_parsing_real(self):
        """Test parsing multipart email with HTML and text"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['multipart']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        email_data = result.data["email_data"]
        
        # Verify headers
        assert email_data["headers"]["subject"] == "Test Subject - Multipart Email"
        assert email_data["headers"]["from"] == "sender@company.com"
        assert "recipient@company.com" in email_data["headers"]["to"]
        assert email_data["headers"]["cc"] == "cc@company.com"
        assert email_data["headers"]["in_reply_to"] == "<original789@company.com>"
        
        # Verify body content
        assert "This is the plain text version" in email_data["body"]["plain_text"]
        assert "<h1>HTML Version</h1>" in email_data["body"]["html_content"]
        assert result.data["confidence"] > 0.8
    
    def test_attachment_extraction_real(self):
        """Test real attachment extraction and saving"""
        output_dir = tempfile.mkdtemp()
        
        try:
            request = ToolRequest(
                tool_id="T14",
                operation="parse",
                input_data={
                    "email_path": self.test_email_files['with_attachments'],
                    "extract_attachments": True,
                    "output_dir": output_dir
                },
                parameters={}
            )
            
            result = self.tool.execute(request)
            
            assert result.status == "success"
            attachments = result.data["email_data"]["attachments"]
            
            # Should have 2 attachments
            assert len(attachments) == 2
            
            # Check text attachment
            text_att = next((att for att in attachments if "test_document.txt" in att["filename"]), None)
            assert text_att is not None
            assert text_att["size"] > 0
            assert "saved_path" in text_att
            assert os.path.exists(text_att["saved_path"])
            
            # Check image attachment
            image_att = next((att for att in attachments if "test_image.png" in att["filename"]), None)
            assert image_att is not None
            assert image_att["content_type"] == "image/png"
            assert "saved_path" in image_att
            assert os.path.exists(image_att["saved_path"])
            
            # Verify stats
            assert result.data["stats"]["attachments_extracted"] == 2
            assert result.data["confidence"] > 0.8
            
        finally:
            # Clean up output directory
            import shutil
            shutil.rmtree(output_dir, ignore_errors=True)
    
    def test_encoded_headers_decoding_real(self):
        """Test real RFC 2047 header decoding"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['encoded_headers']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        headers = result.data["email_data"]["headers"]
        
        # Verify decoded headers
        assert "ÖäÜ" in headers["subject"] or "Test Subject with" in headers["subject"]
        assert "John" in headers["from"] and "john@example.com" in headers["from"]
        assert result.data["stats"]["headers_decoded"] > 0
        assert result.data["confidence"] > 0.7
    
    def test_encoding_detection_real(self):
        """Test real character encoding detection"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['latin1_encoding']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        
        # Should successfully parse despite different encoding
        assert result.data["email_data"]["headers"]["subject"] == "Test Latin-1 Encoding"
        assert "café" in result.data["email_data"]["body"]["plain_text"] or "caf" in result.data["email_data"]["body"]["plain_text"]
        assert result.data["stats"]["encoding_detections"] > 0
        assert result.data["confidence"] > 0.6
    
    def test_malformed_email_handling_real(self):
        """Test handling of malformed email files"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['malformed']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        # Should not fail, but parse as plain text
        assert result.status == "success"
        assert "This is not a valid email message" in result.data["email_data"]["body"]["plain_text"]
        assert result.data["confidence"] < 0.8  # Lower confidence for malformed
    
    def test_nonexistent_file_real(self):
        """Test error handling for non-existent email file"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": "/nonexistent/email.eml"},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "error"
        assert result.error_code.value == "FILE_NOT_FOUND"
        assert "not found" in result.error_message.lower()
        assert result.execution_time > 0
    
    def test_invalid_input_real(self):
        """Test error handling for invalid input parameters"""
        # Missing email_path
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "error"
        assert result.error_code.value == "INVALID_INPUT"
        assert "email_path" in result.error_message
    
    def test_unsupported_file_format_real(self):
        """Test error handling for unsupported file formats"""
        # Create a .txt file instead of .eml
        txt_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
        txt_file.write("This is a text file, not an email")
        txt_file.close()
        
        try:
            request = ToolRequest(
                tool_id="T14",
                operation="parse",
                input_data={"email_path": txt_file.name},
                parameters={}
            )
            
            result = self.tool.execute(request)
            
            assert result.status == "error"
            assert result.error_code.value == "INVALID_INPUT"
            assert "Unsupported email format" in result.error_message
            
        finally:
            os.unlink(txt_file.name)
    
    def test_service_integration_real(self):
        """Test integration with real ServiceManager services"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['simple']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        
        # Verify service manager is used
        assert self.tool.service_manager is not None
        
        # Tool should attempt to create mentions
        # (Implementation depends on actual services being available)
        assert result.data["email_data"]["headers"]["from"] == "sender@example.com"
    
    def test_performance_tracking_real(self):
        """Test real performance metrics collection"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['multipart']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        assert result.execution_time > 0
        assert hasattr(result, 'memory_used')
        
        # Processing stats should be tracked
        assert result.data["stats"]["headers_decoded"] > 0
        assert isinstance(result.data["stats"]["attachments_extracted"], int)
        assert isinstance(result.data["stats"]["encoding_detections"], int)
    
    def test_tool_contract_real(self):
        """Test tool contract specification"""
        contract = self.tool.get_contract()
        
        assert contract["tool_id"] == "T14"
        assert contract["name"] == "Email Parser"
        assert contract["category"] == "document_processing"
        assert "Parse email files" in contract["description"]
        
        # Check input schema
        assert "email_path" in contract["input_schema"]["properties"]
        assert "extract_attachments" in contract["input_schema"]["properties"]
        assert contract["input_schema"]["required"] == ["email_path"]
        
        # Check error codes
        assert len(contract["error_codes"]) > 0
        assert any(code.value == "FILE_NOT_FOUND" for code in contract["error_codes"])
    
    def test_health_check_real(self):
        """Test real health check functionality"""
        health = self.tool.health_check()
        
        assert health["status"] == "healthy"
        assert health["email_module"] == "available"
        assert health["chardet_module"] == "available"
        assert health["test_parsing"] == "successful"
        assert ".eml" in health["supported_formats"]
    
    def test_tool_cleanup_real(self):
        """Test tool cleanup functionality"""
        # Process an email to generate some stats
        output_dir = tempfile.mkdtemp()
        
        try:
            request = ToolRequest(
                tool_id="T14",
                operation="parse",
                input_data={
                    "email_path": self.test_email_files['with_attachments'],
                    "extract_attachments": True,
                    "output_dir": output_dir
                },
                parameters={}
            )
        
            result = self.tool.execute(request)
            assert result.status == "success"
            
            # Verify stats were generated
            assert self.tool.attachments_extracted > 0
            assert self.tool.headers_decoded > 0
            
            # Clean up
            self.tool.cleanup()
            
            # Verify stats were reset
            assert self.tool.attachments_extracted == 0
            assert self.tool.headers_decoded == 0
            assert self.tool.encoding_detections == 0
            
        finally:
            # Clean up output directory
            import shutil
            shutil.rmtree(output_dir, ignore_errors=True)
    
    def test_confidence_calculation_real(self):
        """Test confidence score calculation with real data"""
        # Test with complete email
        request_complete = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['with_attachments']},
            parameters={}
        )
        
        result_complete = self.tool.execute(request_complete)
        
        # Test with minimal email
        request_minimal = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['malformed']},
            parameters={}
        )
        
        result_minimal = self.tool.execute(request_minimal)
        
        # Complete email should have higher confidence
        assert result_complete.data["confidence"] > result_minimal.data["confidence"]
        assert result_complete.data["confidence"] > 0.7
        assert 0.3 <= result_minimal.data["confidence"] <= 0.8
    
    def test_metadata_extraction_real(self):
        """Test comprehensive metadata extraction"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['multipart']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        metadata = result.data["email_data"]["metadata"]
        
        # Verify metadata fields
        assert metadata["file_size"] > 0
        assert metadata["is_multipart"] is True
        assert metadata["has_attachments"] is False  # This email has no attachments
        assert metadata["part_count"] > 1
        assert "creation_time" in metadata
        assert "modification_time" in metadata
        assert metadata["content_type"] == "multipart/alternative"
    
    def test_thread_id_extraction_real(self):
        """Test email thread identification"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['multipart']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        email_data = result.data["email_data"]
        
        # Verify thread information
        assert email_data["message_id"] == "<multipart456@company.com>"
        assert email_data["thread_id"] == "<original789@company.com>"
        assert email_data["headers"]["in_reply_to"] == "<original789@company.com>"
    
    def test_attachment_metadata_real(self):
        """Test detailed attachment metadata extraction"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={
                "email_path": self.test_email_files['with_attachments'],
                "extract_attachments": False  # Just metadata, no saving
            },
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        attachments = result.data["email_data"]["attachments"]
        
        assert len(attachments) == 2
        
        # Check attachment details
        for attachment in attachments:
            assert "filename" in attachment
            assert "size" in attachment
            assert "content_type" in attachment
            assert attachment["size"] > 0
            assert "saved_path" not in attachment  # Not extracted
    
    def test_comprehensive_header_extraction_real(self):
        """Test extraction of all common email headers"""
        request = ToolRequest(
            tool_id="T14",
            operation="parse",
            input_data={"email_path": self.test_email_files['multipart']},
            parameters={}
        )
        
        result = self.tool.execute(request)
        
        assert result.status == "success"
        headers = result.data["email_data"]["headers"]
        
        # Check all expected headers are present
        expected_headers = ["from", "to", "cc", "subject", "date", "message_id", "in_reply_to"]
        for header in expected_headers:
            assert header in headers
            assert headers[header]  # Not empty
        
        # Verify header decoding stats
        assert result.data["stats"]["headers_decoded"] >= len(expected_headers)
</file>

</files>
