This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/core/provenance_manager.py, src/core/citation_validator.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  core/
    citation_validator.py
    provenance_manager.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/core/citation_validator.py">
"""
Citation Validator for verifying citation integrity.

Validates citations against their sources and ensures provenance chains
are complete and verifiable.
"""

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class CitationValidator:
    """
    Validates citations and their provenance chains.
    
    Features:
    - Citation source verification
    - Provenance chain validation
    - Bulk validation support
    - Integrity checking
    """
    
    def __init__(self, provenance_manager):
        """
        Initialize the validator.
        
        Args:
            provenance_manager: ProvenanceManager instance
        """
        self.provenance = provenance_manager
    
    async def validate_citation(self, citation_id: str) -> bool:
        """
        Validate a single citation.
        
        Args:
            citation_id: ID of citation to validate
            
        Returns:
            True if valid, False otherwise
        """
        try:
            # Get citation
            citation = self.provenance._citations.get(citation_id)
            if not citation:
                logger.warning(f"Citation not found: {citation_id}")
                return False
            
            # Check source exists
            source_id = citation.get("source_id")
            if not source_id:
                logger.warning(f"Citation {citation_id} has no source_id")
                return False
            
            # Verify source exists
            source = await self.provenance.get_source(source_id)
            derived = self.provenance._derived_content.get(source_id)
            
            if not source and not derived:
                logger.warning(f"Source {source_id} not found for citation {citation_id}")
                return False
            
            # Verify text exists in source
            if source:
                content = source.get("content", "")
            else:
                content = derived.get("output_text", "")
            
            citation_text = citation.get("text", "")
            if citation_text not in content:
                logger.warning(f"Citation text not found in source: {citation_id}")
                return False
            
            # Verify positions if provided
            start_pos = citation.get("start_pos", 0)
            end_pos = citation.get("end_pos", len(content))
            
            if start_pos < 0 or end_pos > len(content) or start_pos >= end_pos:
                logger.warning(f"Invalid positions for citation {citation_id}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error validating citation {citation_id}: {e}")
            return False
    
    async def validate_provenance_chain(self, citation_id: str) -> bool:
        """
        Validate the complete provenance chain for a citation.
        
        Args:
            citation_id: ID of citation
            
        Returns:
            True if chain is valid, False otherwise
        """
        try:
            chain = await self.provenance.get_provenance_chain(citation_id)
            
            if not chain:
                logger.warning(f"No provenance chain for citation {citation_id}")
                return False
            
            # Verify each link in the chain
            for i in range(len(chain) - 1):
                current = chain[i]
                next_item = chain[i + 1]
                
                # Verify linkage
                if next_item.get("type") == "derived":
                    if next_item.get("source_id") != current.get("id"):
                        logger.warning(f"Broken chain link at position {i}")
                        return False
                elif next_item.get("type") == "citation":
                    # Last item should be the citation
                    if i != len(chain) - 2:
                        logger.warning(f"Citation not at end of chain")
                        return False
            
            # Verify source integrity if it's an original source
            if chain[0].get("type") == "source":
                source_id = chain[0].get("id")
                if not await self.provenance.verify_source_integrity(source_id):
                    logger.warning(f"Source integrity check failed: {source_id}")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error validating provenance chain for {citation_id}: {e}")
            return False
    
    async def validate_bulk(self, citation_ids: List[str]) -> Dict[str, Any]:
        """
        Validate multiple citations.
        
        Args:
            citation_ids: List of citation IDs to validate
            
        Returns:
            Validation results dictionary
        """
        results = {
            "total": len(citation_ids),
            "valid": 0,
            "invalid": 0,
            "invalid_citations": [],
            "errors": []
        }
        
        for citation_id in citation_ids:
            try:
                if await self.validate_citation(citation_id):
                    results["valid"] += 1
                else:
                    results["invalid"] += 1
                    results["invalid_citations"].append(citation_id)
            except Exception as e:
                results["invalid"] += 1
                results["invalid_citations"].append(citation_id)
                results["errors"].append({
                    "citation_id": citation_id,
                    "error": str(e)
                })
        
        return results
    
    async def find_orphaned_citations(self) -> List[Dict[str, Any]]:
        """
        Find citations with missing or invalid sources.
        
        Returns:
            List of orphaned citation records
        """
        orphaned = []
        
        for citation_id, citation in self.provenance._citations.items():
            source_id = citation.get("source_id")
            
            # Check if source exists
            source_exists = (
                source_id in self.provenance._sources or
                source_id in self.provenance._derived_content
            )
            
            if not source_exists:
                orphaned.append({
                    "citation_id": citation_id,
                    "source_id": source_id,
                    "text": citation.get("text", ""),
                    "created_at": citation.get("created_at", ""),
                    "reason": "source_missing"
                })
            elif not await self.validate_citation(citation_id):
                orphaned.append({
                    "citation_id": citation_id,
                    "source_id": source_id,
                    "text": citation.get("text", ""),
                    "created_at": citation.get("created_at", ""),
                    "reason": "validation_failed"
                })
        
        return orphaned
    
    async def generate_validation_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive validation report.
        
        Returns:
            Validation report with statistics and issues
        """
        all_citations = list(self.provenance._citations.keys())
        validation_results = await self.validate_bulk(all_citations)
        
        # Check provenance chains
        chain_valid = 0
        chain_invalid = 0
        
        for citation_id in all_citations:
            if await self.validate_provenance_chain(citation_id):
                chain_valid += 1
            else:
                chain_invalid += 1
        
        # Find orphaned citations
        orphaned = await self.find_orphaned_citations()
        
        # Get statistics
        stats = await self.provenance.get_citation_statistics()
        
        report = {
            "summary": {
                "total_citations": validation_results["total"],
                "valid_citations": validation_results["valid"],
                "invalid_citations": validation_results["invalid"],
                "valid_chains": chain_valid,
                "invalid_chains": chain_invalid,
                "orphaned_citations": len(orphaned)
            },
            "statistics": stats,
            "issues": {
                "invalid_citations": validation_results["invalid_citations"],
                "orphaned_citations": orphaned,
                "validation_errors": validation_results["errors"]
            },
            "generated_at": datetime.now().isoformat()
        }
        
        return report
</file>

<file path="src/core/provenance_manager.py">
"""
Provenance Manager for tracking citation sources and modifications.

Ensures every citation has a verifiable source and maintains a complete
audit trail of all modifications.
"""

import asyncio
import uuid
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Optional
import json
import logging

logger = logging.getLogger(__name__)


class ProvenanceManager:
    """
    Manages provenance tracking for citations and content transformations.
    
    Features:
    - Source document registration with content hashing
    - Citation creation with source verification
    - Modification audit trails
    - Provenance chain tracking
    - Content integrity verification
    """
    
    def __init__(self):
        """Initialize the provenance manager."""
        self._sources: Dict[str, Dict[str, Any]] = {}
        self._citations: Dict[str, Dict[str, Any]] = {}
        self._audit_trails: Dict[str, List[Dict[str, Any]]] = {}
        self._derived_content: Dict[str, Dict[str, Any]] = {}
        self._usage_tracking: Dict[str, List[str]] = {}
        self._lock = asyncio.Lock()
    
    async def register_source(self, source_doc: Dict[str, Any]) -> str:
        """
        Register a source document with content hashing.
        
        Args:
            source_doc: Source document with id, content, and optional metadata
            
        Returns:
            Source ID
        """
        async with self._lock:
            source_id = source_doc.get("id", str(uuid.uuid4()))
            
            # Calculate content hash if not provided
            if "hash" not in source_doc:
                content = source_doc.get("content", "")
                source_doc["hash"] = hashlib.sha256(content.encode()).hexdigest()
            
            # Store source
            self._sources[source_id] = {
                **source_doc,
                "registered_at": datetime.now().isoformat(),
                "type": "source"
            }
            
            logger.info(f"Registered source: {source_id}")
            return source_id
    
    async def create_citation(self, source_id: str, text: str, 
                            start_pos: int, end_pos: int,
                            context: Optional[str] = None,
                            metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Create a citation with source verification.
        
        Args:
            source_id: ID of the source document
            text: The cited text
            start_pos: Start position in source
            end_pos: End position in source
            context: Optional surrounding context
            metadata: Optional additional metadata
            
        Returns:
            Citation record
            
        Raises:
            ValueError: If source not found or text not in source
        """
        async with self._lock:
            # Verify source exists
            if source_id not in self._sources and source_id not in self._derived_content:
                raise ValueError(f"Source not found: {source_id}")
            
            # Get source content
            if source_id in self._sources:
                source = self._sources[source_id]
                content = source.get("content", "")
            else:
                source = self._derived_content[source_id]
                content = source.get("output_text", "")
            
            # Verify text exists in source
            if text not in content:
                raise ValueError(f"Text not found in source: '{text}'")
            
            # Verify positions
            if start_pos < 0 or end_pos > len(content) or start_pos >= end_pos:
                raise ValueError(f"Invalid text positions: {start_pos}-{end_pos}")
            
            # Create citation
            citation_id = str(uuid.uuid4())
            citation = {
                "id": citation_id,
                "source_id": source_id,
                "text": text,
                "start_pos": start_pos,
                "end_pos": end_pos,
                "context": context or content[max(0, start_pos-50):min(len(content), end_pos+50)],
                "metadata": metadata or {},
                "created_at": datetime.now().isoformat(),
                "type": "citation",
                "provenance_chain": await self._build_provenance_chain(source_id)
            }
            
            self._citations[citation_id] = citation
            
            # Initialize audit trail
            self._audit_trails[citation_id] = [{
                "timestamp": citation["created_at"],
                "operation": "create",
                "text": text,
                "actor": "system"
            }]
            
            logger.info(f"Created citation: {citation_id}")
            return citation
    
    async def modify_citation(self, citation_id: str, new_text: str,
                            reason: str, modifier: str) -> Dict[str, Any]:
        """
        Modify a citation with audit trail.
        
        Args:
            citation_id: ID of citation to modify
            new_text: New citation text
            reason: Reason for modification
            modifier: ID of user/system making modification
            
        Returns:
            Modified citation record
        """
        async with self._lock:
            if citation_id not in self._citations:
                raise ValueError(f"Citation not found: {citation_id}")
            
            citation = self._citations[citation_id]
            old_text = citation["text"]
            
            # Update citation
            citation["text"] = new_text
            citation["modified_at"] = datetime.now().isoformat()
            citation["last_modifier"] = modifier
            
            # Add to audit trail
            self._audit_trails[citation_id].append({
                "timestamp": citation["modified_at"],
                "operation": "modify",
                "text": new_text,
                "old_text": old_text,
                "reason": reason,
                "modifier": modifier
            })
            
            logger.info(f"Modified citation: {citation_id}")
            return citation
    
    async def get_audit_trail(self, citation_id: str) -> List[Dict[str, Any]]:
        """Get complete audit trail for a citation."""
        return self._audit_trails.get(citation_id, [])
    
    async def get_source(self, source_id: str) -> Optional[Dict[str, Any]]:
        """Get source document by ID."""
        return self._sources.get(source_id)
    
    async def create_derived_content(self, source_id: str, operation: str,
                                   input_text: str, output_text: str,
                                   tool: str) -> Dict[str, Any]:
        """
        Track derived content from transformations.
        
        Args:
            source_id: ID of source content
            operation: Type of operation (extract, summarize, etc.)
            input_text: Input to the operation
            output_text: Output from the operation
            tool: Tool/model used for transformation
            
        Returns:
            Derived content record
        """
        async with self._lock:
            derived_id = str(uuid.uuid4())
            
            derived = {
                "id": derived_id,
                "source_id": source_id,
                "operation": operation,
                "input_text": input_text,
                "output_text": output_text,
                "tool": tool,
                "created_at": datetime.now().isoformat(),
                "type": "derived",
                "provenance_chain": await self._build_provenance_chain(source_id)
            }
            
            self._derived_content[derived_id] = derived
            logger.info(f"Created derived content: {derived_id}")
            return derived
    
    async def _build_provenance_chain(self, source_id: str) -> List[str]:
        """Build provenance chain from source."""
        chain = []
        current_id = source_id
        
        while current_id:
            chain.append(current_id)
            
            # Check if it's derived content
            if current_id in self._derived_content:
                current_id = self._derived_content[current_id].get("source_id")
            else:
                # Reached original source
                break
        
        return list(reversed(chain))
    
    async def get_provenance_chain(self, citation_id: str) -> List[Dict[str, Any]]:
        """Get complete provenance chain for a citation."""
        if citation_id not in self._citations:
            return []
        
        citation = self._citations[citation_id]
        chain_ids = citation.get("provenance_chain", [])
        
        chain = []
        for node_id in chain_ids:
            if node_id in self._sources:
                chain.append(self._sources[node_id])
            elif node_id in self._derived_content:
                chain.append(self._derived_content[node_id])
        
        # Add the citation itself
        chain.append(citation)
        
        return chain
    
    async def verify_source_integrity(self, source_id: str) -> bool:
        """Verify source content hasn't been tampered with."""
        if source_id not in self._sources:
            return False
        
        source = self._sources[source_id]
        content = source.get("content", "")
        stored_hash = source.get("hash", "")
        
        # Calculate current hash
        current_hash = hashlib.sha256(content.encode()).hexdigest()
        
        return current_hash == stored_hash
    
    async def track_citation_usage(self, citation_id: str, used_in: str) -> None:
        """Track where a citation is used."""
        async with self._lock:
            if citation_id not in self._usage_tracking:
                self._usage_tracking[citation_id] = []
            
            self._usage_tracking[citation_id].append(used_in)
    
    async def get_citation_statistics(self) -> Dict[str, Any]:
        """Get statistics about citations and sources."""
        stats = {
            "total_sources": len(self._sources),
            "total_citations": len(self._citations),
            "total_derived": len(self._derived_content),
            "citations_by_source": {},
            "usage_count": {}
        }
        
        # Count citations per source
        for citation in self._citations.values():
            source_id = citation["source_id"]
            if source_id not in stats["citations_by_source"]:
                stats["citations_by_source"][source_id] = 0
            stats["citations_by_source"][source_id] += 1
        
        # Usage counts
        for citation_id, uses in self._usage_tracking.items():
            stats["usage_count"][citation_id] = len(uses)
        
        return stats
    
    # Test helper methods (should not be in production)
    async def _tamper_source_content(self, source_id: str, new_content: str) -> None:
        """FOR TESTING ONLY: Tamper with source content."""
        if source_id in self._sources:
            self._sources[source_id]["content"] = new_content
    
    async def _corrupt_citation(self, citation_id: str) -> None:
        """FOR TESTING ONLY: Corrupt a citation."""
        if citation_id in self._citations:
            self._citations[citation_id]["source_id"] = "corrupted_source"
</file>

</files>
