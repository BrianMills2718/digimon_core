This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/tools/phase1/t08_xml_loader_unified.py, tests/unit/test_t08_xml_loader_unified.py, src/tools/base_tool.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  tools/
    phase1/
      t08_xml_loader_unified.py
    base_tool.py
tests/
  unit/
    test_t08_xml_loader_unified.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/tools/phase1/t08_xml_loader_unified.py">
"""
T08: XML Document Loader - Unified Interface Implementation
Loads and parses XML documents with comprehensive structure preservation and validation.
"""
from typing import Dict, Any, Optional, List, Union
import os
from pathlib import Path
import uuid
from datetime import datetime
import xml.etree.ElementTree as ET
import json
import logging
from src.tools.base_tool import BaseTool, ToolRequest, ToolResult, ToolContract, ToolStatus, ToolErrorCode
from src.core.service_manager import ServiceManager
from src.core.advanced_data_models import Document, ObjectType, QualityTier
logger = logging.getLogger(__name__)
class T08XMLLoaderUnified(BaseTool):
    """T08: XML Document Loader with unified interface"""
    def __init__(self, service_manager: ServiceManager):
        """Initialize with service manager"""
        super().__init__(service_manager)
        self.tool_id = "T08"
        self.identity_service = service_manager.identity_service
        self.provenance_service = service_manager.provenance_service
        self.quality_service = service_manager.quality_service
        self._temp_files = []
    def get_contract(self) -> ToolContract:
        """Return tool contract specification"""
        return ToolContract(
            tool_id=self.tool_id,
            name="XML Document Loader",
            description="Load and parse XML documents with structure preservation and validation",
            category="document_processing",
            input_schema={
                "type": "object",
                "properties": {
                    "file_path": {
                        "type": "string",
                        "description": "Path to XML file to load"
                    },
                    "workflow_id": {
                        "type": "string",
                        "description": "Optional workflow ID for tracking"
                    },
                    "parse_options": {
                        "type": "object",
                        "properties": {
                            "preserve_whitespace": {"type": "boolean", "default": False},
                            "include_attributes": {"type": "boolean", "default": True},
                            "flatten_text": {"type": "boolean", "default": False},
                            "namespace_aware": {"type": "boolean", "default": True}
                        },
                        "default": {}
                    }
                },
                "required": ["file_path"]
            },
            output_schema={
                "type": "object",
                "properties": {
                    "document": {
                        "type": "object",
                        "properties": {
                            "document_id": {"type": "string"},
                            "document_ref": {"type": "string"},
                            "file_path": {"type": "string"},
                            "file_name": {"type": "string"},
                            "file_size": {"type": "integer"},
                            "xml_structure": {"type": "object"},
                            "text_content": {"type": "string"},
                            "element_count": {"type": "integer"},
                            "attributes_count": {"type": "integer"},
                            "namespace_count": {"type": "integer"},
                            "confidence": {"type": "number"},
                            "quality_tier": {"type": "string"},
                            "created_at": {"type": "string"}
                        },
                        "required": ["document_id", "xml_structure", "text_content", "confidence", "element_count"]
                    }
                },
                "required": ["document"]
            },
            dependencies=["identity_service", "provenance_service", "quality_service"],
            performance_requirements={
                "max_execution_time": 60.0,  # 60 seconds for large XML files
                "max_memory_mb": 1024,       # 1GB for XML processing
                "min_confidence": 0.8        # Minimum confidence threshold
            },
            error_conditions=[
                "FILE_NOT_FOUND",
                "INVALID_FILE_TYPE",
                "XML_MALFORMED",
                "XML_PARSE_ERROR",
                "NAMESPACE_ERROR",
                "MEMORY_LIMIT_EXCEEDED"
            ]
        )
    def execute(self, request: ToolRequest) -> ToolResult:
        """Execute XML loading with unified interface"""
        self._start_execution()
        try:
            # Validate input
            if not self.validate_input(request.input_data):
                return self._create_error_result(
                    request,
                    "INVALID_INPUT",
                    "Input validation failed. Required: file_path"
                )
            # Extract parameters
            file_path = request.input_data.get("file_path")
            workflow_id = request.input_data.get("workflow_id")
            parse_options = request.input_data.get("parse_options", {})
            # Set default parse options
            parse_options = {
                "preserve_whitespace": parse_options.get("preserve_whitespace", False),
                "include_attributes": parse_options.get("include_attributes", True),
                "flatten_text": parse_options.get("flatten_text", False),
                "namespace_aware": parse_options.get("namespace_aware", True)
            }
            # Validate file path
            validation_result = self._validate_file_path(file_path)
            if not validation_result["valid"]:
                # Use formal error code enum
                error_code = getattr(ToolErrorCode, validation_result["error_code"], ToolErrorCode.VALIDATION_FAILED)
                return self._create_error_result(
                    request,
                    error_code.value,
                    validation_result["error_message"]
                )
            file_path = Path(file_path)
            # Start provenance tracking
            operation_id = self.provenance_service.start_operation(
                tool_id=self.tool_id,
                operation_type="load_xml_document",
                used={},
                parameters={
                    "file_path": str(file_path),
                    "workflow_id": workflow_id,
                    "parse_options": parse_options
                }
            )
            # Generate workflow ID if not provided
            if not workflow_id:
                workflow_id = f"wf_{uuid.uuid4().hex[:8]}"
            # Create document ID
            document_id = f"{workflow_id}_{file_path.stem}"
            document_ref = f"storage://document/{document_id}"
            # Parse XML document
            parsing_result = self._parse_xml_document(file_path, parse_options)
            if parsing_result["status"] != "success":
                # Use formal error code enum
                error_code_str = parsing_result.get("error_code", "XML_PARSE_ERROR")
                error_code = getattr(ToolErrorCode, error_code_str, ToolErrorCode.XML_PARSE_ERROR)
                return self._create_error_result(
                    request,
                    error_code.value,
                    parsing_result["error"]
                )
            # Calculate confidence
            confidence = self._calculate_confidence(
                xml_structure=parsing_result["xml_structure"],
                element_count=parsing_result["element_count"],
                file_size=file_path.stat().st_size,
                parse_errors=parsing_result.get("parse_warnings", [])
            )
            # Create document data
            document_data = {
                "document_id": document_id,
                "document_ref": document_ref,
                "file_path": str(file_path),
                "file_name": file_path.name,
                "file_size": file_path.stat().st_size,
                "xml_structure": parsing_result["xml_structure"],
                "text_content": parsing_result["text_content"],
                "element_count": parsing_result["element_count"],
                "attributes_count": parsing_result["attributes_count"],
                "namespace_count": parsing_result["namespace_count"],
                "confidence": confidence,
                "created_at": datetime.now().isoformat(),
                "tool_version": "1.0.0",
                "parse_options": parse_options,
                "root_element": parsing_result.get("root_element", "unknown")
            }
            # Assess quality
            quality_result = self.quality_service.assess_confidence(
                object_ref=document_ref,
                base_confidence=confidence,
                factors={
                    "element_count": min(1.0, parsing_result["element_count"] / 1000),
                    "structure_depth": min(1.0, parsing_result.get("max_depth", 1) / 10),
                    "file_size": min(1.0, file_path.stat().st_size / (1024 * 1024)),
                    "namespace_usage": min(1.0, parsing_result["namespace_count"] / 5)
                },
                metadata={
                    "xml_type": "structured",
                    "parse_method": "ElementTree",
                    "root_element": parsing_result.get("root_element", "unknown")
                }
            )
            if quality_result["status"] == "success":
                document_data["confidence"] = quality_result["confidence"]
                document_data["quality_tier"] = quality_result["quality_tier"]
            # Complete provenance
            self.provenance_service.complete_operation(
                operation_id=operation_id,
                outputs=[document_ref],
                success=True,
                metadata={
                    "element_count": parsing_result["element_count"],
                    "text_length": len(parsing_result["text_content"]),
                    "confidence": document_data["confidence"],
                    "namespace_count": parsing_result["namespace_count"]
                }
            )
            # Get execution metrics
            execution_time, memory_used = self._end_execution()
            # Create success result
            return ToolResult(
                tool_id=self.tool_id,
                status="success",
                data={
                    "document": document_data
                },
                metadata={
                    "operation_id": operation_id,
                    "workflow_id": workflow_id,
                    "parse_method": "ElementTree",
                    "parse_options": parse_options
                },
                execution_time=execution_time,
                memory_used=memory_used
            )
        except Exception as e:
            logger.error(f"Unexpected error in {self.tool_id}: {e}", exc_info=True)
            return self._create_error_result(
                request,
                "UNEXPECTED_ERROR",
                f"Unexpected error during XML loading: {str(e)}"
            )
    def _validate_file_path(self, file_path: str) -> Dict[str, Any]:
        """Validate file path for security and existence"""
        if not file_path:
            return {
                "valid": False,
                "error_code": "INVALID_INPUT",
                "error_message": "File path cannot be empty"
            }
        try:
            path = Path(file_path)
            # Check if path exists
            if not path.exists():
                return {
                    "valid": False,
                    "error_code": "FILE_NOT_FOUND",
                    "error_message": f"File not found: {file_path}"
                }
            # Check if it's a file
            if not path.is_file():
                return {
                    "valid": False,
                    "error_code": "INVALID_INPUT",
                    "error_message": f"Path is not a file: {file_path}"
                }
            # Check extension
            allowed_extensions = ['.xml', '.xhtml', '.svg', '.rss', '.atom']
            if path.suffix.lower() not in allowed_extensions:
                return {
                    "valid": False,
                    "error_code": "INVALID_FILE_TYPE",
                    "error_message": f"Invalid file extension. Allowed: {allowed_extensions}"
                }
            # Basic security check - prevent path traversal
            if ".." in str(path) or str(path).startswith("/etc"):
                return {
                    "valid": False,
                    "error_code": "VALIDATION_FAILED",
                    "error_message": "Invalid file path"
                }
            return {"valid": True}
        except Exception as e:
            return {
                "valid": False,
                "error_code": "VALIDATION_FAILED",
                "error_message": f"Path validation failed: {str(e)}"
            }
    def _parse_xml_document(self, file_path: Path, parse_options: Dict[str, Any]) -> Dict[str, Any]:
        """Parse XML document using ElementTree"""
        try:
            # Parse the XML file
            tree = ET.parse(file_path)
            root = tree.getroot()
            # Extract document information
            xml_structure = self._extract_xml_structure(root, parse_options)
            text_content = self._extract_text_content(root, parse_options)
            element_count = self._count_elements(root)
            attributes_count = self._count_attributes(root)
            namespace_count = self._count_namespaces(root)
            max_depth = self._calculate_max_depth(root)
            return {
                "status": "success",
                "xml_structure": xml_structure,
                "text_content": text_content,
                "element_count": element_count,
                "attributes_count": attributes_count,
                "namespace_count": namespace_count,
                "max_depth": max_depth,
                "root_element": root.tag,
                "parse_warnings": []
            }
        except ET.ParseError as e:
            logger.error(f"XML parse error: {str(e)}")
            return {
                "status": "error",
                "error": f"XML parse error: {str(e)}",
                "error_code": "XML_MALFORMED"
            }
        except Exception as e:
            logger.error(f"Failed to parse XML document: {str(e)}")
            return {
                "status": "error",
                "error": f"Failed to parse XML document: {str(e)}",
                "error_code": "XML_PARSE_ERROR"
            }
    def _extract_xml_structure(self, element: ET.Element, parse_options: Dict[str, Any]) -> Dict[str, Any]:
        """Extract XML structure as nested dictionary"""
        result = {
            "tag": element.tag,
            "text": element.text.strip() if element.text and not parse_options.get("flatten_text", False) else None,
            "tail": element.tail.strip() if element.tail else None
        }
        # Include attributes if requested
        if parse_options.get("include_attributes", True) and element.attrib:
            result["attributes"] = dict(element.attrib)
        # Process child elements
        children = []
        for child in element:
            child_structure = self._extract_xml_structure(child, parse_options)
            children.append(child_structure)
        if children:
            result["children"] = children
        return result
    def _extract_text_content(self, element: ET.Element, parse_options: Dict[str, Any]) -> str:
        """Extract all text content from XML structure"""
        text_parts = []
        # Add element text
        if element.text:
            text = element.text.strip() if not parse_options.get("preserve_whitespace", False) else element.text
            if text:
                text_parts.append(text)
        # Process children recursively
        for child in element:
            child_text = self._extract_text_content(child, parse_options)
            if child_text:
                text_parts.append(child_text)
            # Add tail text
            if child.tail:
                tail = child.tail.strip() if not parse_options.get("preserve_whitespace", False) else child.tail
                if tail:
                    text_parts.append(tail)
        separator = " " if parse_options.get("flatten_text", False) else "\n"
        return separator.join(text_parts)
    def _count_elements(self, element: ET.Element) -> int:
        """Count total number of elements in XML tree"""
        count = 1  # Count current element
        for child in element:
            count += self._count_elements(child)
        return count
    def _count_attributes(self, element: ET.Element) -> int:
        """Count total number of attributes in XML tree"""
        count = len(element.attrib)
        for child in element:
            count += self._count_attributes(child)
        return count
    def _count_namespaces(self, element: ET.Element) -> int:
        """Count unique namespaces in XML tree"""
        namespaces = set()
        def extract_namespace(tag):
            if tag.startswith('{'):
                end = tag.find('}')
                if end > 0:
                    return tag[1:end]
            return None
        def collect_namespaces(elem):
            ns = extract_namespace(elem.tag)
            if ns:
                namespaces.add(ns)
            for child in elem:
                collect_namespaces(child)
        collect_namespaces(element)
        return len(namespaces)
    def _calculate_max_depth(self, element: ET.Element, current_depth: int = 1) -> int:
        """Calculate maximum depth of XML tree"""
        if not list(element):
            return current_depth
        max_child_depth = current_depth
        for child in element:
            child_depth = self._calculate_max_depth(child, current_depth + 1)
            max_child_depth = max(max_child_depth, child_depth)
        return max_child_depth
    def _calculate_confidence(self, xml_structure: Dict[str, Any], element_count: int, 
                            file_size: int, parse_errors: List[str]) -> float:
        """Calculate confidence score for XML parsing"""
        base_confidence = 0.9  # High confidence for successful XML parsing
        # Factors that affect confidence
        factors = []
        # Element count factor - be more generous for smaller XML files
        if element_count > 50:
            factors.append(0.95)
        elif element_count > 5:
            factors.append(0.9)
        else:
            factors.append(0.85)
        # File size factor - be more generous for test files
        if file_size > 1024 * 1024:  # > 1MB
            factors.append(0.95)
        elif file_size > 10 * 1024:  # > 10KB
            factors.append(0.9)
        else:
            factors.append(0.85)
        # Structure complexity factor
        has_attributes = self._has_attributes_in_structure(xml_structure)
        has_nested_elements = self._has_nested_elements(xml_structure)
        if has_attributes and has_nested_elements:
            factors.append(0.95)
        elif has_attributes or has_nested_elements:
            factors.append(0.9)
        else:
            factors.append(0.85)
        # Parse errors penalty
        if parse_errors:
            factors.append(0.7)  # Reduce confidence if there were warnings
        # Calculate average - use simple average instead of weighted
        if factors:
            final_confidence = sum([base_confidence] + factors) / (len(factors) + 1)
        else:
            final_confidence = base_confidence
        # Ensure confidence is in valid range
        return max(0.1, min(1.0, final_confidence))
    def _has_attributes_in_structure(self, structure: Dict[str, Any]) -> bool:
        """Check if XML structure has attributes"""
        if structure.get("attributes"):
            return True
        children = structure.get("children", [])
        for child in children:
            if self._has_attributes_in_structure(child):
                return True
        return False
    def _has_nested_elements(self, structure: Dict[str, Any]) -> bool:
        """Check if XML structure has nested elements"""
        children = structure.get("children", [])
        return len(children) > 0
    def health_check(self) -> ToolResult:
        """Check tool health and readiness"""
        try:
            # Check if xml.etree.ElementTree is available
            import xml.etree.ElementTree as ET
            et_available = True
        except ImportError:
            et_available = False
        # Check service dependencies
        services_healthy = True
        if self.services:
            try:
                # Basic check that services exist
                _ = self.identity_service
                _ = self.provenance_service
                _ = self.quality_service
            except:
                services_healthy = False
        healthy = et_available and services_healthy
        return ToolResult(
            tool_id=self.tool_id,
            status="success" if healthy else "error",
            data={
                "healthy": healthy,
                "elementtree_available": et_available,
                "services_healthy": services_healthy,
                "supported_formats": [".xml", ".xhtml", ".svg", ".rss", ".atom"],
                "status": self.status.value
            },
            metadata={
                "timestamp": datetime.now().isoformat()
            },
            execution_time=0.0,
            memory_used=0
        )
    def validate_input(self, input_data: Any) -> bool:
        """Validate input against tool contract with XML-specific validation"""
        # Call base validation first
        if not super().validate_input(input_data):
            return False
        # Additional validation for XML loader
        if isinstance(input_data, dict):
            file_path = input_data.get("file_path")
            if not file_path or not file_path.strip():
                return False
        return True
    def cleanup(self) -> bool:
        """Clean up any temporary files"""
        try:
            # Clean up temp files if any
            for temp_file in self._temp_files:
                try:
                    if os.path.exists(temp_file):
                        os.remove(temp_file)
                except:
                    pass
            self._temp_files = []
            self.status = ToolStatus.READY
            return True
        except Exception as e:
            logger.error(f"Cleanup failed: {e}")
            return False
</file>

<file path="tests/unit/test_t08_xml_loader_unified.py">
"""
Mock-free unit tests for T08 XML Loader Unified
Tests the unified XML loader tool with real XML processing using xml.etree.ElementTree.
No mocking is used - all functionality is tested with real data and real processing.
"""
import pytest
import tempfile
import xml.etree.ElementTree as ET
from pathlib import Path
from unittest.mock import Mock
import os
from src.tools.phase1.t08_xml_loader_unified import T08XMLLoaderUnified
from src.core.service_manager import ServiceManager
from src.tools.base_tool import ToolRequest
class TestT08XMLLoaderUnifiedMockFree:
    def setup_method(self):
        """Set up test fixtures with real ServiceManager - NO mocks"""
        # Real ServiceManager - NO mocking
        self.service_manager = ServiceManager()
        self.tool = T08XMLLoaderUnified(service_manager=self.service_manager)
        # Create real test XML files
        self.test_files = self._create_real_test_xml_files()
    def teardown_method(self):
        """Clean up real test files"""
        for file_path in self.test_files.values():
            try:
                if os.path.exists(file_path):
                    os.unlink(file_path)
            except:
                pass
    def _create_real_test_xml_files(self) -> dict:
        """Create real XML test files for testing"""
        test_files = {}
        # Simple XML file
        simple_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<root>
    <title>Test Document</title>
    <content>This is a test XML document with simple structure.</content>
    <metadata>
        <author>Test Author</author>
        <date>2024-01-01</date>
    </metadata>
</root>'''
        simple_file = tempfile.NamedTemporaryFile(mode='w', suffix='.xml', delete=False)
        simple_file.write(simple_xml)
        simple_file.close()
        test_files['simple'] = simple_file.name
        # Complex XML with attributes and namespaces
        complex_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<books xmlns:fiction="http://example.com/fiction" xmlns:nonfiction="http://example.com/nonfiction">
    <fiction:book id="1" genre="fantasy" available="true">
        <title lang="en">The Fantasy Novel</title>
        <author nationality="US">
            <firstName>John</firstName>
            <lastName>Smith</lastName>
        </author>
        <publication year="2023" publisher="Fantasy Press"/>
        <description>A thrilling fantasy adventure with magic and dragons.</description>
        <chapters>
            <chapter number="1" title="The Beginning">
                <content>Once upon a time in a magical land...</content>
            </chapter>
            <chapter number="2" title="The Journey">
                <content>The hero embarked on a perilous journey...</content>
            </chapter>
        </chapters>
    </fiction:book>
    <nonfiction:book id="2" genre="science" available="false">
        <title lang="en">Understanding Physics</title>
        <author nationality="UK">
            <firstName>Jane</firstName>
            <lastName>Doe</lastName>
        </author>
        <publication year="2022" publisher="Science Books Ltd"/>
        <description>A comprehensive guide to modern physics principles.</description>
        <sections>
            <section name="Mechanics" pages="50"/>
            <section name="Thermodynamics" pages="75"/>
            <section name="Quantum Physics" pages="100"/>
        </sections>
    </nonfiction:book>
</books>'''
        complex_file = tempfile.NamedTemporaryFile(mode='w', suffix='.xml', delete=False)
        complex_file.write(complex_xml)
        complex_file.close()
        test_files['complex'] = complex_file.name
        # RSS feed XML
        rss_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
    <channel>
        <title>Test News Feed</title>
        <link>http://example.com</link>
        <description>Test RSS feed for XML parsing</description>
        <item>
            <title>Breaking News: XML Parser Works</title>
            <link>http://example.com/news1</link>
            <description>The XML parser successfully processed this RSS feed.</description>
            <pubDate>Mon, 01 Jan 2024 12:00:00 GMT</pubDate>
        </item>
        <item>
            <title>Technology Update</title>
            <link>http://example.com/news2</link>
            <description>New advances in XML processing technology.</description>
            <pubDate>Tue, 02 Jan 2024 15:30:00 GMT</pubDate>
        </item>
    </channel>
</rss>'''
        rss_file = tempfile.NamedTemporaryFile(mode='w', suffix='.xml', delete=False)
        rss_file.write(rss_xml)
        rss_file.close()
        test_files['rss'] = rss_file.name
        # Malformed XML for error testing
        malformed_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<root>
    <unclosed_tag>This tag is not closed properly
    <another_tag>Content here</another_tag>
</root>'''
        malformed_file = tempfile.NamedTemporaryFile(mode='w', suffix='.xml', delete=False)
        malformed_file.write(malformed_xml)
        malformed_file.close()
        test_files['malformed'] = malformed_file.name
        return test_files
    def test_tool_contract_real(self):
        """Test tool contract with REAL contract validation"""
        contract = self.tool.get_contract()
        # Verify contract structure
        assert contract.tool_id == "T08"
        assert contract.name == "XML Document Loader"
        assert contract.category == "document_processing"
        assert "file_path" in contract.input_schema["required"]
        assert "document" in contract.output_schema["required"]
        assert len(contract.dependencies) > 0
        # Verify performance requirements
        assert "max_execution_time" in contract.performance_requirements
        assert "max_memory_mb" in contract.performance_requirements
        assert "min_confidence" in contract.performance_requirements
        # Verify error conditions
        assert "XML_MALFORMED" in contract.error_conditions
        assert "FILE_NOT_FOUND" in contract.error_conditions
    def test_simple_xml_loading_real(self):
        """Test loading simple XML with REAL processing"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['simple'],
                "workflow_id": "test_workflow_simple"
            },
            parameters={}
        )
        result = self.tool.execute(request)
        # Verify successful execution
        assert result.status == "success"
        assert result.tool_id == "T08"
        assert result.execution_time > 0
        # Verify document data
        doc = result.data["document"]
        assert doc["document_id"] == "test_workflow_simple_" + Path(self.test_files['simple']).stem
        assert doc["file_name"] == Path(self.test_files['simple']).name
        assert doc["element_count"] > 0
        assert doc["confidence"] > 0.5
        assert len(doc["text_content"]) > 0
        # Verify XML structure
        xml_structure = doc["xml_structure"]
        assert xml_structure["tag"] == "root"
        assert "children" in xml_structure
        assert len(xml_structure["children"]) >= 3  # title, content, metadata
        # Verify specific content
        assert "Test Document" in doc["text_content"]
        assert "Test Author" in doc["text_content"]
    def test_complex_xml_with_namespaces_real(self):
        """Test loading complex XML with namespaces and attributes with REAL processing"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['complex'],
                "workflow_id": "test_workflow_complex",
                "parse_options": {
                    "include_attributes": True,
                    "namespace_aware": True
                }
            },
            parameters={}
        )
        result = self.tool.execute(request)
        # Verify successful execution
        assert result.status == "success"
        # Verify document data
        doc = result.data["document"]
        assert doc["element_count"] > 10  # Complex structure
        assert doc["attributes_count"] > 5  # Multiple attributes
        assert doc["namespace_count"] == 2  # fiction and nonfiction namespaces
        assert doc["confidence"] > 0.5
        # Verify XML structure with attributes
        xml_structure = doc["xml_structure"]
        assert xml_structure["tag"] == "books"
        # Find book elements and verify attributes
        book_elements = [child for child in xml_structure.get("children", []) if "book" in child["tag"]]
        assert len(book_elements) == 2
        # Verify attributes are included
        for book in book_elements:
            assert "attributes" in book
            assert "id" in book["attributes"]
            assert "genre" in book["attributes"]
    def test_rss_feed_parsing_real(self):
        """Test RSS feed XML parsing with REAL processing"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['rss'],
                "workflow_id": "test_workflow_rss"
            },
            parameters={}
        )
        result = self.tool.execute(request)
        # Verify successful execution
        assert result.status == "success"
        # Verify RSS-specific content
        doc = result.data["document"]
        assert "Test News Feed" in doc["text_content"]
        assert "Breaking News: XML Parser Works" in doc["text_content"]
        assert "Technology Update" in doc["text_content"]
        # Verify RSS structure
        xml_structure = doc["xml_structure"]
        assert xml_structure["tag"] == "rss"
        assert "attributes" in xml_structure
        assert xml_structure["attributes"]["version"] == "2.0"
    def test_parse_options_functionality_real(self):
        """Test different parse options with REAL processing"""
        # Test with flattened text
        request_flat = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['simple'],
                "parse_options": {
                    "flatten_text": True,
                    "preserve_whitespace": False
                }
            },
            parameters={}
        )
        result_flat = self.tool.execute(request_flat)
        assert result_flat.status == "success"
        # Test without attributes
        request_no_attr = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['complex'],
                "parse_options": {
                    "include_attributes": False
                }
            },
            parameters={}
        )
        result_no_attr = self.tool.execute(request_no_attr)
        assert result_no_attr.status == "success"
        # Verify attributes are not included
        xml_structure = result_no_attr.data["document"]["xml_structure"]
        def check_no_attributes(element):
            assert "attributes" not in element or not element["attributes"]
            for child in element.get("children", []):
                check_no_attributes(child)
        check_no_attributes(xml_structure)
    def test_error_handling_malformed_xml_real(self):
        """Test error handling with REAL malformed XML"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['malformed']
            },
            parameters={}
        )
        result = self.tool.execute(request)
        # Verify error handling
        assert result.status == "error"
        assert result.error_code == "XML_MALFORMED"
        assert "XML parse error" in result.error_message
    def test_file_not_found_error_real(self):
        """Test file not found error with REAL missing file"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": "/path/to/nonexistent/file.xml"
            },
            parameters={}
        )
        result = self.tool.execute(request)
        # Verify error handling
        assert result.status == "error"
        assert result.error_code == "FILE_NOT_FOUND"
        assert "File not found" in result.error_message
    def test_invalid_file_type_error_real(self):
        """Test invalid file type error with REAL non-XML file"""
        # Create a non-XML file
        txt_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
        txt_file.write("This is not an XML file")
        txt_file.close()
        try:
            request = ToolRequest(
                tool_id="T08",
                operation="load_xml",
                input_data={
                    "file_path": txt_file.name
                },
                parameters={}
            )
            result = self.tool.execute(request)
            # Verify error handling
            assert result.status == "error"
            assert result.error_code == "INVALID_FILE_TYPE"
            assert "Invalid file extension" in result.error_message
        finally:
            os.unlink(txt_file.name)
    def test_input_validation_real(self):
        """Test input validation with REAL validation logic"""
        # Test missing file_path
        result = self.tool.validate_input({})
        assert result == False
        result = self.tool.validate_input({"file_path": ""})
        assert result == False
        # Test valid input
        result = self.tool.validate_input({"file_path": "/some/path.xml"})
        assert result == True
    def test_health_check_real(self):
        """Test health check with REAL service verification"""
        result = self.tool.health_check()
        # Verify health check structure
        assert isinstance(result.data, dict)
        assert "healthy" in result.data
        assert "elementtree_available" in result.data
        assert "services_healthy" in result.data
        assert "supported_formats" in result.data
        # Verify ElementTree is available
        assert result.data["elementtree_available"] == True
        # Verify supported formats
        supported_formats = result.data["supported_formats"]
        assert ".xml" in supported_formats
        assert ".xhtml" in supported_formats
        assert ".svg" in supported_formats
        assert ".rss" in supported_formats
    def test_cleanup_functionality_real(self):
        """Test cleanup functionality with REAL resource management"""
        # Add some temp files to the tool
        temp_file = tempfile.NamedTemporaryFile(delete=False)
        temp_file.close()
        self.tool._temp_files.append(temp_file.name)
        # Verify cleanup works
        cleanup_result = self.tool.cleanup()
        assert cleanup_result == True
        assert len(self.tool._temp_files) == 0
        assert not os.path.exists(temp_file.name)
    def test_confidence_calculation_real(self):
        """Test confidence calculation with REAL XML parsing metrics"""
        # Test with simple XML
        request_simple = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={"file_path": self.test_files['simple']},
            parameters={}
        )
        result_simple = self.tool.execute(request_simple)
        confidence_simple = result_simple.data["document"]["confidence"]
        # Test with complex XML
        request_complex = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={"file_path": self.test_files['complex']},
            parameters={}
        )
        result_complex = self.tool.execute(request_complex)
        confidence_complex = result_complex.data["document"]["confidence"]
        # Complex XML should have equal or higher confidence due to more structure
        assert confidence_simple > 0.5
        assert confidence_complex > 0.5
        assert confidence_complex >= confidence_simple - 0.1  # Allow small variance
    def test_performance_metrics_real(self):
        """Test performance metrics with REAL execution measurement"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={"file_path": self.test_files['complex']},
            parameters={}
        )
        result = self.tool.execute(request)
        # Verify performance metrics are captured
        assert result.execution_time > 0
        assert result.memory_used >= 0  # Memory might be 0 in some environments
        # Verify reasonable execution time (should be under 1 second for test files)
        assert result.execution_time < 1.0
    def test_service_integration_real(self):
        """Test service integration with REAL services"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['simple'],
                "workflow_id": "test_service_integration"
            },
            parameters={}
        )
        result = self.tool.execute(request)
        # Verify service integration
        assert result.status == "success"
        assert "operation_id" in result.metadata
        # Verify provenance tracking
        operation_id = result.metadata["operation_id"]
        assert operation_id is not None
        # Verify quality assessment
        doc = result.data["document"]
        assert "quality_tier" in doc
        assert doc["confidence"] > 0
    def test_xml_structure_extraction_real(self):
        """Test XML structure extraction with REAL parsing"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={"file_path": self.test_files['complex']},
            parameters={}
        )
        result = self.tool.execute(request)
        xml_structure = result.data["document"]["xml_structure"]
        # Verify structure completeness
        assert xml_structure["tag"] == "books"
        assert "children" in xml_structure
        # Verify nested structure
        books = [child for child in xml_structure["children"] if "book" in child["tag"]]
        assert len(books) == 2
        # Verify attributes
        for book in books:
            assert "attributes" in book
            assert "id" in book["attributes"]
            # Verify nested children
            book_children = book.get("children", [])
            titles = [child for child in book_children if child["tag"] == "title"]
            assert len(titles) == 1
    def test_text_content_extraction_real(self):
        """Test text content extraction with REAL text processing"""
        request = ToolRequest(
            tool_id="T08",
            operation="load_xml",
            input_data={
                "file_path": self.test_files['rss'],
                "parse_options": {"flatten_text": True}
            },
            parameters={}
        )
        result = self.tool.execute(request)
        text_content = result.data["document"]["text_content"]
        # Verify all expected text is extracted
        assert "Test News Feed" in text_content
        assert "Breaking News: XML Parser Works" in text_content
        assert "Technology Update" in text_content
        assert "http://example.com" in text_content
        # Verify text is properly formatted
        assert len(text_content.strip()) > 0
        assert text_content.count("Breaking News") == 1  # Should appear exactly once
</file>

<file path="src/tools/base_tool.py">
"""
Base Tool Infrastructure for Unified Tool Interface
Provides the contract-first design for all KGAS tools.
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum
import time
import psutil
from datetime import datetime
class ToolStatus(Enum):
    """Tool operational status"""
    READY = "ready"
    PROCESSING = "processing"
    ERROR = "error"
    MAINTENANCE = "maintenance"
class ToolErrorCode(Enum):
    """Standardized tool error codes for programmatic handling"""
    # Input/Validation Errors
    INVALID_INPUT = "INVALID_INPUT"
    FILE_NOT_FOUND = "FILE_NOT_FOUND"
    INVALID_FILE_TYPE = "INVALID_FILE_TYPE"
    VALIDATION_FAILED = "VALIDATION_FAILED"
    # Processing Errors
    PARSE_ERROR = "PARSE_ERROR"
    XML_MALFORMED = "XML_MALFORMED"
    XML_PARSE_ERROR = "XML_PARSE_ERROR"
    YAML_SYNTAX_ERROR = "YAML_SYNTAX_ERROR"
    YAML_PARSE_ERROR = "YAML_PARSE_ERROR"
    EXCEL_CORRUPTED = "EXCEL_CORRUPTED"
    EXCEL_PASSWORD_PROTECTED = "EXCEL_PASSWORD_PROTECTED"
    POWERPOINT_CORRUPTED = "POWERPOINT_CORRUPTED"
    POWERPOINT_PASSWORD_PROTECTED = "POWERPOINT_PASSWORD_PROTECTED"
    SHEET_NOT_FOUND = "SHEET_NOT_FOUND"
    # Library/Dependency Errors
    LIBRARY_MISSING = "LIBRARY_MISSING"
    PPTX_LIBRARY_MISSING = "PPTX_LIBRARY_MISSING"
    UNSAFE_YAML_CONTENT = "UNSAFE_YAML_CONTENT"
    NAMESPACE_ERROR = "NAMESPACE_ERROR"
    # System Errors
    MEMORY_LIMIT_EXCEEDED = "MEMORY_LIMIT_EXCEEDED"
    EXECUTION_TIMEOUT = "EXECUTION_TIMEOUT"
    HEALTH_CHECK_FAILED = "HEALTH_CHECK_FAILED"
    UNEXPECTED_ERROR = "UNEXPECTED_ERROR"
@dataclass(frozen=True)
class ToolRequest:
    """Standardized tool input format"""
    tool_id: str
    operation: str
    input_data: Any
    parameters: Dict[str, Any] = field(default_factory=dict)
    context: Optional[Dict[str, Any]] = field(default=None)
    validation_mode: bool = field(default=False)
@dataclass(frozen=True)
class ToolResult:
    """Standardized tool output format"""
    tool_id: str
    status: str  # "success" or "error"
    data: Any = field(default=None)
    metadata: Dict[str, Any] = field(default_factory=dict)
    execution_time: float = field(default=0.0)
    memory_used: int = field(default=0)
    error_code: Optional[str] = field(default=None)
    error_message: Optional[str] = field(default=None)
@dataclass(frozen=True)
class ToolContract:
    """Tool capability and requirement specification"""
    tool_id: str
    name: str
    description: str
    category: str  # "document_processing", "graph", "table", "vector", "cross_modal"
    input_schema: Dict[str, Any] = field(default_factory=dict)
    output_schema: Dict[str, Any] = field(default_factory=dict)
    dependencies: List[str] = field(default_factory=list)
    performance_requirements: Dict[str, Any] = field(default_factory=dict)
    error_conditions: List[str] = field(default_factory=list)
class BaseTool(ABC):
    """Base class all tools MUST inherit from"""
    def __init__(self, services):
        """Initialize with service manager"""
        self.services = services
        self.tool_id = self.__class__.__name__  # Override in subclass
        self.status = ToolStatus.READY
        self._start_time = None
        self._start_memory = None
    @abstractmethod
    def get_contract(self) -> ToolContract:
        """Return tool contract specification"""
        pass
    @abstractmethod
    def execute(self, request: ToolRequest) -> ToolResult:
        """Execute tool operation with standardized input/output"""
        pass
    def validate_input(self, input_data: Any) -> bool:
        """Validate input against tool contract"""
        # Basic implementation - override for specific validation
        if input_data is None:
            return False
        contract = self.get_contract()
        required_fields = contract.input_schema.get("required", [])
        if isinstance(input_data, dict):
            for field in required_fields:
                if field not in input_data:
                    return False
        return True
    def health_check(self) -> ToolResult:
        """Check tool health and readiness"""
        try:
            # Basic health check - override for specific checks
            healthy = self.status in [ToolStatus.READY, ToolStatus.PROCESSING]
            return ToolResult(
                tool_id=self.tool_id,
                status="success" if healthy else "error",
                data={
                    "healthy": healthy,
                    "status": self.status.value,
                    "contract": self.get_contract().name
                },
                metadata={
                    "timestamp": datetime.now().isoformat()
                },
                execution_time=0.0,
                memory_used=0
            )
        except Exception as e:
            return ToolResult(
                tool_id=self.tool_id,
                status="error",
                data={"healthy": False},
                metadata={"error": str(e)},
                execution_time=0.0,
                memory_used=0,
                error_code="HEALTH_CHECK_FAILED",
                error_message=str(e)
            )
    def get_status(self) -> ToolStatus:
        """Get current tool status"""
        return self.status
    def cleanup(self) -> bool:
        """Clean up tool resources"""
        # Basic cleanup - override for specific cleanup
        self.status = ToolStatus.READY
        return True
    def _start_execution(self):
        """Start execution tracking"""
        self._start_time = time.time()
        try:
            self._start_memory = psutil.Process().memory_info().rss
        except:
            self._start_memory = 0  # Fallback if psutil fails
        self.status = ToolStatus.PROCESSING
    def _end_execution(self) -> tuple:
        """End execution tracking and return metrics"""
        execution_time = time.time() - self._start_time if self._start_time else 0.0
        try:
            current_memory = psutil.Process().memory_info().rss
            memory_used = current_memory - self._start_memory if self._start_memory else 0
        except:
            memory_used = 0  # Fallback if psutil fails
        self.status = ToolStatus.READY
        return execution_time, memory_used
    def _create_error_result(self, request: ToolRequest, error_code: str, error_message: str) -> ToolResult:
        """Create standardized error result"""
        execution_time, memory_used = self._end_execution()
        self.status = ToolStatus.ERROR
        return ToolResult(
            tool_id=self.tool_id,
            status="error",
            data=None,
            metadata={
                "operation": request.operation,
                "timestamp": datetime.now().isoformat()
            },
            execution_time=execution_time,
            memory_used=memory_used,
            error_code=error_code,
            error_message=error_message
        )
</file>

</files>
